# Sorting Algorithms Practical Exercises

These exercises are designed to help you practice and reinforce your understanding of various sorting algorithms.

## Exercise 1: Implement and Test CountSort
- Implement the CountSort algorithm for sorting integer lists.
- Write unit tests to verify your implementation with various input cases, including empty lists, lists with duplicates, and negative numbers.
- Analyze the time and space complexity of your implementation.

## Exercise 2: Analyze RadixSort Behavior
- Use the provided RadixSort implementation to sort different lists of non-negative integers.
- Create test cases with varying number lengths and sizes.
- Measure and compare the performance of RadixSort against CountSort on large datasets.
- Explain scenarios where RadixSort is more efficient than CountSort and vice versa.

## Exercise 3: Compare QuickSort and MergeSort
- Implement unit tests for QuickSort and MergeSort using the provided code.
- Generate random lists and compare the running times of QuickSort and MergeSort.
- Identify cases where one algorithm outperforms the other and explain why.

## Exercise 4: Visualize SelectionSort
- Use the animate_SelectionSort function to visualize the sorting process on small lists.
- Modify the animation to highlight the current minimum element and the part of the list already sorted.
- Reflect on the algorithm's behavior and its efficiency.

## Exercise 5: Implement InsertionSort Unit Tests
- Write comprehensive unit tests for the InsertionSort algorithm.
- Include edge cases such as already sorted lists, reverse sorted lists, and lists with repeated elements.
- Discuss the best, average, and worst-case time complexities.

## Exercise 6: ShellSort Gap Sequence Experimentation
- Experiment with different gap sequences in the ShellSort implementation.
- Test the effect of these sequences on the sorting time for large lists.
- Document your findings and suggest the most efficient gap sequence based on your experiments.

## Exercise 7: Extend SortingComparison
- Add your own sorting algorithm implementation (e.g., BubbleSort or HeapSort) to the SortingComparison module.
- Compare its performance with the existing algorithms on various list sizes.
- Present your results and analyze the efficiency of your algorithm.

## Exercise 8: Stability of Sorting Algorithms
- Research which of the provided sorting algorithms are stable.
- Design test cases to demonstrate stability or instability.
- Modify an unstable algorithm to make it stable, if possible, and test your modification.

## Exercise 9: Sorting Algorithm Selection
- Given different types of input data (e.g., nearly sorted, reverse sorted, random, with many duplicates), recommend the most suitable sorting algorithm from the provided implementations.
- Justify your choices based on algorithm characteristics and empirical results.

---

These exercises will help deepen your understanding of sorting algorithms, their implementation details, and their practical performance considerations.
