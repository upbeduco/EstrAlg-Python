# Sorting Algorithms Practical Exercises

These exercises are designed to help you practice and reinforce your understanding of various sorting algorithms.

## Exercise 1: Visualize SelectionSort
- Use the animate_SelectionSort function to visualize the sorting process on small lists.
- Modify the animation to highlight the current minimum element and the part of the list already sorted.
- Reflect on the algorithm's behavior and its efficiency.

## Exercise 2: Implement InsertionSort Unit Tests
- Write comprehensive unit tests for the InsertionSort algorithm.
- Include edge cases such as already sorted lists, reverse sorted lists, and lists with repeated elements.
- Discuss the best, average, and worst-case time complexities.

## Exercise 3: ShellSort Gap Sequence Experimentation
- Experiment with different gap sequences in the ShellSort implementation.
- Test the effect of these sequences on the sorting time for large lists.
- Document your findings and suggest the most efficient gap sequence based on your experiments.

## Exercise 4: Compare QuickSort and MergeSort
- Implement unit tests for QuickSort and MergeSort using the provided code.
- Generate random lists and compare the running times of QuickSort and MergeSort.
- Identify cases where one algorithm outperforms the other and explain why.

## Exercise 5: Stability of Sorting Algorithms
- Research which of the provided sorting algorithms are stable.
- Design test cases to demonstrate stability or instability.
- Modify an unstable algorithm to make it stable, if possible, and test your modification.

## Exercise 6: Implement and Test CountSort
- Analyze the time and space complexity CountSort.

## Exercise 7: Analyze RadixSort Behavior
- Perform a step-by-step analysis of the workings of RadixSort.
- Measure and compare the performance of RadixSort against CountSort on large datasets.
- Explain scenarios where RadixSort is more efficient than CountSort and vice versa.

## Exercise 8: Extend SortingComparison
- Add your own sorting algorithm implementation (e.g., BubbleSort or HeapSort) to the SortingComparison module.
- Compare its performance with the existing algorithms on various list sizes.
- Present your results and analyze the efficiency of your algorithm.

## Exercise 9: Sorting Algorithm Selection
- Given different types of input data (e.g., nearly sorted, reverse sorted, random, with many duplicates), recommend the most suitable sorting algorithm from the provided implementations.
- Justify your choices based on algorithm characteristics and empirical results.

